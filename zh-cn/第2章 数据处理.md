# 第二章。数据处理的内容、地点、时间和方法

好了，聚会的人们，现在是具体的时候了!

第一章主要集中在三个方面：术语，准确定义我在使用 "流 "这样的重载术语时的意思；批处理与流，比较两类系统的理论能力，并假设只有两样东西是使流系统超越批处理系统所必需的：正确性和时间推理工具；以及数据处理模式，研究批处理和流系统在处理有界和无界数据时采取的概念性方法。

在本章中，我们将进一步关注第1章中的数据处理模式，但要更详细，并在具体的例子中进行讨论。当我们结束时，我们将涵盖我所认为的稳健的无序数据处理所需的核心原则和概念；这些是推理时间的工具，真正让你超越经典的批处理。

为了让你感觉到事情的实际情况，我使用了Apache Beam的代码片段，再加上延时图1来提供概念的视觉表现。Apache Beam是一个统一的编程模型和可移植层，用于批处理和流处理，有一套不同语言（如Java和Python）的具体SDKs。用Apache Beam编写的管道可以在任何支持的执行引擎（Apache Apex、Apache Flink、Apache Spark、Cloud Dataflow等）上可移植地运行。

我在这里用Apache Beam做例子，并不是因为这是一本Beam的书（它不是），而是因为它最完整地体现了本书所描述的概念。在最初写 "流102 "的时候（那时它还是Google Cloud Dataflow的Dataflow模型，而不是Apache Beam的Beam模型），它是现存的唯一一个能够为我们在这里所涉及的所有例子提供必要表达能力的系统。一年半之后，我很高兴地说，情况发生了很大变化，大多数主要的系统已经或正在朝着支持与本书描述的模型类似的方向发展。所以，请放心，我们在这里所涉及的概念，虽然是通过Beam的镜头来了解的，但也同样适用于你将遇到的大多数其他系统。



## 路线图

为了帮助本章奠定基础，我想列出五个主要概念，它们将成为本章所有讨论的基础，实际上也是第一部分其余大部分内容的基础。

在第一章中，我首先建立了事件时间（事件发生的时间）和处理时间（处理过程中观察到的时间）之间的关键区别。这为本书提出的一个主要论点奠定了基础：如果你关心事件的正确性和实际发生的背景，你必须根据其固有的事件时间来分析数据，而不是分析过程中遇到的处理时间。

然后，我介绍了窗口化的概念（即沿着时间边界划分数据集），这是一种常用的方法，用来应对无边界的数据源在技术上可能永远不会结束的事实。窗口化策略的一些简单例子是固定窗口和滑动窗口，但更复杂的窗口化类型，如会话（其中窗口由数据本身的特征定义；例如，捕捉每个用户活动的会话，然后是不活动的间隙）也看到广泛的使用。

除了这两个概念之外，我们现在要仔细研究另外三个概念。

**触发器**
触发器是一种机制，用于声明一个窗口的输出何时应相对于某些外部信号而被具体化。触发器在选择输出的时间方面提供了灵活性。在某种意义上，你可以把它们看成是一种流控机制，用于规定何时应该实现结果。另一种看法是，触发器就像相机上的快门释放器，允许你声明何时对正在计算的结果进行快照。

触发器也使你有可能在一个窗口的发展过程中多次观察其输出。这反过来又为随着时间的推移完善结果打开了大门，从而可以在数据到达时提供推测性的结果，以及处理上游数据（修订）随时间的变化或晚到的数据（例如，在移动场景中，某人的手机在其离线时记录了各种动作及其事件时间，然后在重新连接时继续上传这些事件进行处理）。

**水印**
水印是一个关于事件时间的输入完整性的概念。一个时间值为X的水印发出这样的声明。"所有事件时间小于X的输入数据都被观察到了"。因此，当观察一个没有已知终点的无界数据源时，水印充当了进度的衡量标准。我们在这一章中谈到了水印的基础知识，然后Slava在第三章中对这一主题进行了深入探讨。

**积累**
累积模式规定了在同一窗口中观察到的多个结果之间的关系。这些结果可能是完全不相干的；也就是说，代表了随时间变化的独立三角洲，或者它们之间可能有重叠。不同的积累模式有不同的语义和与之相关的成本，因此在各种用例中找到了适用性。

另外，因为我认为这样更容易理解所有这些概念之间的关系，我们在回答四个问题的结构中重温旧的，探索新的，我提出所有这些问题对每个无界数据处理问题都是至关重要的。

计算的结果是什么？这个问题由管道内的转换类型来回答。这包括像计算总和、建立直方图、训练机器学习模型等事情。这基本上也是经典批处理所回答的问题

在事件时间的什么地方计算结果？这个问题是通过在流水线中使用事件时间窗口来回答的。这包括第一章中常见的窗口化例子（固定、滑动和会话）；似乎没有窗口化概念的用例（例如，时间无关的处理；经典的批处理一般也属于这一类）；以及其他更复杂的窗口化类型，例如有时间限制的拍卖。还要注意的是，如果你把记录到达系统时的进入时间指定为事件时间，它也可以包括处理时间窗口化。

在处理时间中，什么时候结果会被物化？这个问题可以通过使用触发器和（可选择的）水印来回答。这个主题有无限的变化，但最常见的模式是那些涉及重复更新的模式（即物化视图语义），那些利用水印来提供每个窗口的单一输出，只有在相应的输入被认为是完整的（即在每个窗口基础上应用的经典批处理语义），或两者的一些组合。

结果的细化是如何关联的？这个问题由所使用的积累类型来回答：抛弃（在这种情况下，结果都是独立的和不同的），积累（在这种情况下，后来的结果建立在先前的结果之上），或者积累和收回（在这种情况下，积累的值加上先前触发的值的收回都被排放出来）。

在本书的其余部分，我们将更详细地研究这些问题的每一个。而且，是的，我将会把这个颜色计划的事情搞得一团糟，试图让人们非常清楚哪些概念与What/Where/When/How习语中的哪些问题有关。不客气 <winky-smiley/>.2



## Batch Foundations: 什么和哪里

好了，让我们开始这个派对吧。第一站：批处理。

What：转换
在经典的批处理中应用的变换回答了这个问题。"计算的是什么结果？" 尽管你可能已经熟悉了经典的批处理，但我们还是要从这里开始，因为它是我们添加所有其他概念的基础。

在本章的其余部分（事实上，在本书的大部分内容中），我们看一个例子：在一个由九个值组成的简单数据集上计算键入的整数和。让我们想象一下，我们写了一个基于团队的手机游戏，我们想建立一个管道，通过将用户手机报告的个人分数相加来计算团队分数。如果我们在一个名为 "UserScores "的SQL表中捕获我们的九个示例分数，它可能看起来像这样。

```sql
SELECT * FROM UserScores ORDER BY EventTime;
```

| Name  | Team  | Score | EventTime | ProcTime |
| ----- | ----- | ----- | --------- | -------- |
| Julie | TeamX | 5     | 12:00:26  | 12:05:19 |
| Frank | TeamX | 9     | 12:01:26  | 12:08:19 |
| Ed    | TeamX | 7     | 12:02:26  | 12:05:39 |
| Julie | TeamX | 8     | 12:03:06  | 12:07:06 |
| Amy   | TeamX | 3     | 12:03:39  | 12:06:13 |
| Fred  | TeamX | 4     | 12:04:19  | 12:06:39 |
| Naomi | TeamX | 3     | 12:06:39  | 12:07:19 |
| Becky | TeamX | 8     | 12:07:26  | 12:08:39 |
| Naomi | TeamX | 1     | 12:07:46  | 12:09:00 |

请注意，这个例子中的所有分数都来自同一个团队的用户；这是为了保持例子的简单性，因为我们在接下来的图表中的维度数量有限。因为我们是按团队分组的，所以我们实际上只关心最后三栏。

**分数**
与此事件相关的个人用户得分

**事件时间**
分数的事件时间；也就是说，分数发生的时间。

**处理时间（ProcTime)**
分数的处理时间；也就是说，管道观察到分数的时间

对于每个管道的例子，我们会看一个延时图，突出数据是如何随时间演变的。这些图在我们关心的两个时间维度上绘制了我们的九个分数：X轴的事件时间和Y轴的处理时间。图2-1说明了输入数据的静态图是什么样子的。

