# 第1章 流式传输101

如今，由于充分的原因，流数据处理已成为大数据中的一大问题。其中包括：

- 企业渴望对数据有更及时的洞察力，而切换到流数据是降低延迟的好方法

- 使用为此类永无止境的数据量设计的系统，可以更轻松地驯服在现代业务中越来越普遍的海量无边界数据集。

在数据到达时对其进行处理，可以使工作负载随着时间的推移更均匀地分布，从而产生更加一致且可预测的资源消耗。

尽管由业务驱动的人们对流数据的兴趣激增，但与批量生产的同类产品相比，流数据系统长期以来仍相对不成熟。直到最近，趋势才最终朝着另一个方向摇摆。在我那更加坎bump的时刻，我希望这可能部分归因于我最初在“ Streaming 101”和“ Streaming 102”博客文章中担任过的扎实工作（本书的前几章相当显然基于）。但实际上，看到流系统成熟，还有很多聪明而活跃的人喜欢构建流数据，这在业界引起了很多兴趣。

尽管我认为赢得一般流数据宣传的斗争已经取得了成功，但我仍将或多或少地提出来自“流数据101”的原始论点。一方面，即使许多行业已经开始注意战斗的呼声，它们在今天仍然非常适用。还有两个人，那里还有很多人还没有拿到备忘录。本书是扩展这些观点的扩展尝试。

首先，我将介绍一些重要的背景信息，这些信息将有助于构想我要讨论的其余主题。我在三个特定部分中执行此操作：

- 术语
  要精确地讨论复杂的主题，需要对术语进行精确的定义。对于某些在当前使用中超载解释的术语，我将尽力明确我在讲这些术语时的意思。

- 能力
  我评论了流数据系统经常被察觉到的缺点。我还提出了我认为数据处理系统构建者需要采用的思路，以解决未来现代数据消费者的需求。

- 时间语义
  我介绍了与数据处理相关的两个主要时间语义，展示了它们之间的关系，并指出了这两个域带来的一些困难。

## 术语：什么是流数据？
在继续之前，我想先解决一件事：什么是流数据？如今，流数据一词用于表示各种不同的事物（为简单起见，到目前为止，我一直在宽松地使用它），这可能导致人们对流数据到底是什么或流数据系统真正具有的能力产生误解。因此，我宁愿精确地定义该术语。

问题的症结在于，许多应该由它们描述的东西（无限制的数据处理，近似结果等）已经通过历史上的完成方式（即，通过流执行引擎）被俗称地描述了。 ）。术语的缺乏精确性使流数据真正意味着什么，并且在某些情况下，这给流数据系统本身带来了负担，这意味着流数据系统的功能仅限于历史上被描述为“流数据”的特征，例如近似或推测性结果。

鉴于设计良好的流系统与现有的批处理引擎一样具有（能够在技术上更多地）产生正确，一致，可重复的结果的能力，因此我更倾向于将“流”这一术语隔离为一个非常具体的含义：

- 流数据系统
一种数据处理引擎，设计时考虑了无限的数据集。[^1]

如果我想讨论低延迟，近似或推测性的结果，我会使用这些特定的词，而不是不精确地称它们为“流”。

在讨论人们可能遇到的不同类型的数据时，精确的术语也很有用。从我的角度来看，有两个重要的（正交的）维度定义了给定数据集的形状：基数和构成。

数据集的基数决定其大小，基数最显着的方面是给定数据集是有限的还是无限的。这是我更喜欢用来描述数据集中的粗基数的两个术语：

- 有界数据
  一种大小有限的数据集。

- 无限数据
  一种数据集，其大小是无限的（至少在理论上是无限的）。

基数很重要，因为无限数据集的无限性质给使用它们的数据处理框架带来了额外的负担。下一节将对此进行更多介绍。

另一方面，数据集的构成决定了其物理表现形式。结果，宪法规定了人们可以与所讨论的数据进行交互的方式。我们不会深入研究const直到第6章为止，但为了让您简要了解事物，有两个重要的主要构成：

- 表
  在特定时间点的数据集的整体视图。 SQL系统传统上是在表中处理的。

- 流[^2]
  数据集随时间变化的逐元素视图。数据处理系统的MapReduce沿袭传统上是在流中处理的。

我们在第6、8、9章中非常深入地研究了流与表之间的关系，在第8章中，我们还了解了将它们联系在一起的时变关系的统一底层概念。但是直到那时，我们主要处理流，因为那是构造管道开发人员直接与当今大多数数据处理系统（批处理和流）进行交互的地方。这也是宪法最自然地体现了流处理所特有的挑战。

### 关于流数据的极大限制
关于这一点，让我们接下来讨论流数据系统可以做什么和不能做什么，重点是可以。我想在本章中谈到的最大的事情之一就是精心设计的流系统的功能。从历史上看，流数据系统一直局限于提供低延迟，不准确或推测性结果的小众市场，通常将其与功能更强大的批处理系统结合使用，以提供最终正确的结果。换句话说，就是Lambda架构。

对于尚未熟悉Lambda体系结构的人员，基本思想是将流系统与批处理系统一起运行，两者都执行基本相同的计算。流式系统为您提供了低延迟，不准确的结果（由于使用了近似算法，或者因为流式系统本身不提供正确性），一段时间后，批处理系统也随之滚动并为您提供了正确的输出。它最初是由Twitter的Nathan Marz（Storm的创建者）提出的，但最终获得了相当大的成功，因为它在当时是一个绝妙的主意。流引擎对于正确性部门来说有点令人失望，而批处理引擎本来就如您所期望的那样笨拙，因此Lambda为您提供了一种吃蛋糕的好方法。不幸的是，维护Lambda系统很麻烦：您需要构建，配置和维护管道的两个独立版本，然后以某种方式最后合并来自两个管道的结果。

作为花了很多年的时间来研究高度一致的流引擎的人，我还发现Lambda体系结构的整个原理有点不好。毫不奇怪，当杰伊·克雷普斯（Jay Kreps）发表“质疑Lambda建筑”一文时，我是他的忠实粉丝。这是针对双模式执行的必要性的首批高度可见的声明之一。愉快。 Kreps在使用诸如Kafka之类的可重播系统作为流互连时解决了可重复性问题，并提出了Kappa架构，这基本上意味着要使用精心设计的系统运行单个流水线，该系统专门针对手头的工作。我不认为该概念需要使用自己的希腊字母名称，但原则上我完全支持该想法。

老实说，我会更进一步。我认为精心设计的流系统实际上提供了批处理功能的严格超集。模数也许是效率的增量，但现在应该不需要批处理系统。 Apache Flink员工深信这一想法，并建立了一个即使在“批处理”模式下也可以全天候流式传输的系统，这一点值得称赞。我喜欢它。

> <center><a style="bold">批处理和流效率差异<a></center>
>
> 我提出的建议不是流系统的固有限制，而仅仅是迄今为止大多数流系统中设计选择的结果。批处理和流处理之间的效率差异主要是由于批处理系统中捆绑的增加和混洗传输效率的提高所致。现代批处理系统不遗余力地实现复杂的优化，这些优化使用令人惊讶的适度计算资源来实现显着水平的吞吐量。没有任何理由可以将使批处理系统成为当今效率最重要的明智见解的类型并入为无限制数据而设计的系统中，从而为用户提供了我们通常认为的高延迟，高效率之间的灵活选择。批处理和低延迟，低效率的“流”处理。通过在相同的统一模型下提供批处理和流式运行程序，这实际上是我们在Google上使用Cloud Dataflow所做的事情。在我们的案例中，我们使用单独的运行器，因为我们碰巧有两个针对其特定用例进行了优化的独立设计的系统。从工程角度来看，长期来看，我很乐意看到我们将两者合并为一个该系统结合了两者的最佳部分，同时仍保持选择适当效率水平的灵活性。但这不是我们今天所拥有的。老实说，由于有了统一的数据流模型，它甚至不是绝对必要的；因此，它很可能永远不会发生。

所有这些的必然结果是，流传输系统的广泛成熟以及用于无边界数据处理的强大框架相结合，将使Lambda体系结构及时降级到其所属的大数据历史的上古时代。我相信现在已经成为现实。因为这样做（也就是说，在自己的游戏中胜过批量），您实际上只需要两件事：

- 正确性
  这使您与批处理相等。从根本上说，正确性可以归结为一致的存储。流系统需要一种检查时间上的持久状态的方法（Kreps在他的“为什么本地状态是流处理中的基本原语”一文中谈到），并且必须设计得足够好以在发生机器故障时保持一致。几年前，当Spark Streaming首次出现在公共大数据场景中时，它是本来就黑暗的流数据世界中一致性的灯塔。值得庆幸的是，此后一切都得到了很大的改善，但是值得注意的是，仍然有许多流系统在缺乏强一致性的情况下仍在尝试。
重申这一点，因为这一点很重要：一次处理就需要强大的一致性，[^3]正确性是必须的，这对于任何有机会满足或超过批处理系统能力的系统都是必需的。除非您真的不在乎结果，否则我恳请您避免使用任何无法提供高度一致状态的流系统。批处理系统不需要您提前进行验证，如果它们能够产生正确的答案；不要在无法达到相同标准的流数据系统上浪费时间。
如果您想了解更多有关在流系统中获得强大一致性所需的知识，建议您查看MillWheel，Spark Streaming和Flink快照论文。这三个人都花费大量时间讨论一致性。鲁汶（Reuven）将在第5章中深入介绍一致性保证，如果您仍然渴望获得更多信息，那么在文献中和其他地方也有大量关于此主题的质量信息。

- **时间推理工具**
  这使您超越了批次。良好的时间推理工具对于处理事件时间偏斜不同的无界，无序数据至关重要。越来越多的现代数据集表现出这些特征，并且现有的批处理系统（以及许多流系统）缺乏必要的工具来应对它们带来的困难（尽管现在这种情况正在迅速改变，即使在我撰写本文时也是如此）。我们将在本书的大部分内容中解释和关注这一点的各个方面。
首先，我们对时间语义的重要概念有了基本的了解，之后，我们将更深入地了解变化的事件-时间偏差的无边界，无序数据的含义。然后，我们将在本章的其余部分中讨论使用批处理和流式系统进行有界和无界数据处理的常用方法。

### 事件时间与处理时间
要说服无界限的数据处理，需要对所涉及的时间语义有清楚的了解。在任何数据处理系统中，我们通常都会关注两个时间语义：

- **事件时间**
事件实际发生的时间。

- **处理时间** 
在系统中观察到事件的时间。

并非所有的用例都关心事件的发生时间（如果您不关心事件的发生，万岁！您的生活会更轻松），但很多情况下都是如此。示例包括表征用户随时间的行为，大多数计费应用程序以及许多类型的异常检测，仅举几例。

在理想情况下，事件时间和处理时间将始终相等，事件发生时将立即进行处理。但是，实际情况并非如此，事件时间与处理时间之间的偏差不仅非零，而且通常是基础输入源，执行引擎和硬件的特征的高度可变的函数。可能影响偏斜程度的因素包括：

- 共享资源限制，例如网络拥塞，网络分区或非专用环境中的共享CPU

- 软件原因，例如分布式系统逻辑，争用等等

- 数据本身的特征，例如密钥分布，吞吐量差异或无序差异（即一架载满人的手机，在整个飞行过程中都将手机离线使用后，将其退出了飞机模式）

结果，如果您在任何实际系统中绘制事件时间和处理时间的进度图，通常最终会得到一些类似于图1-1中红线的内容。

![image-20210330142928152](C:\Users\Rayan\Documents\笔记\streamingsystem\zh-cn\第一章 流式计算 101.assets\image-20210330142928152.png)

图1-1。时间语义映射。这x轴表示系统中事件时间的完整性；也就是说，在事件时间中的时间X可以观察到事件时间小于X的所有数据。 y轴[^4]表示处理时间的进度；也就是说，数据处理系统在执行时观察到的正常时钟时间。
在图1-1中，斜率为1的黑色虚线表示理想状态，其中处理时间和事件时间完全相等;红线代表现实。在此示例中，系统在处理时间开始时稍微滞后，在中间偏向理想位置，然后再次向末尾滞后。乍一看，此图中有两种类型的时滞可见，每种时滞都在不同的时间语义中：

**处理时间**
理想线和红线之间的垂直距离是处理时间语义中的滞后。该距离告诉您在给定时间发生事件与处理事件之间观察到的延迟时间（处理时间）。这也许是两个偏斜中更自然，更直观的。

**事件时间**
理想线和红线之间的水平距离是管道中此时的事件时间偏斜量。它告诉您管道当前（在事件时间中）距离理想状态还有多远。

实际上，在任何给定时间点的处理时间滞后和事件时间偏斜是相同的。它们只是查看同一事物的两种方式。[^5]关于滞后/偏斜的重要提示是：由于事件时间和处理时间之间的总体映射不是静态的（即，滞后/偏斜可以随时间任意变化） ，这意味着，如果您关心数据的事件时间（即事件实际发生的时间），则不能仅在管道观察到它们的时间范围内分析数据。不幸的是，这是许多为无限制数据设计的系统历来运行的方式。为了应对无边界数据集的无限性质，这些系统通常提供一些窗口化输入数据的概念。我们稍后将对加窗进行更深入的讨论，但这本质上是指沿着时间边界将数据集切成有限的片段。如果您关心正确性，并且有兴趣在事件时间的背景下分析数据，则无法像许多系统一样使用处理时间（即处理时间窗口）来定义这些时间边界。在处理时间和事件时间之间没有一致的关联，您的一些事件时间数据最终将在错误的处理时间窗口内结束（由于分布式系统固有的滞后性，许多类型的输入具有在线/离线特性）来源等），将正确性扔出窗外。我们在以下各节中的许多示例以及本书的其余部分中，将更详细地讨论这个问题。

不幸的是，在按事件时间进行窗口浏览时，图片也不完全是玫瑰色。在数据不受限制的情况下，混乱和可变偏斜会引发事件时间窗口的完整性问题：在处理时间和事件时间之间缺乏可预测的映射，如何确定在给定事件时间内观察到所有数据的时间X？对于许多现实世界的数据源，您根本无法做到。但是，当今使用的绝大多数数据处理系统都依赖于完整性的某种概念，这在将它们应用于无界数据集时会处于严重的劣势。

我建议，与其尝试将无边界的数据整理成最终完成的有限信息批次，不如设计能够使我们生活在这些复杂数据集所带来的不确定性世界中的工具。新数据将到达，旧数据可能会被收回或更新，我们构建的任何系统都应能够自行应对这些事实，完整性的概念是针对特定和适当用例的便捷优化，而不是跨语义的必要性他们都是。

在详细介绍这种方法的外观之前，让我们结束另一个有用的背景知识：通用数据处理模式。

## 数据处理模式
至此，我们已经建立了足够的背景知识，可以开始研究当今有界和无界数据处理中常见的使用模式的核心类型。我们着眼于两种类型的处理，并在相关的情况下，在我们关注的两种主要类型的引擎（批处理和流式处理）的背景下进行研究，在这种情况下，我本质上将微批处理与流式处理混为一谈，因为两者之间的差异在这个级别上并不十分重要）。

### 有界数据
从概念上讲，处理边界数据非常简单，并且每个人都可能熟悉。在图1-2中，我们从左边开始是充满熵的数据集。我们通过一些数据处理引擎（通常是批处理，尽管设计良好的流引擎也可以运行）运行它，例如MapReduce，并在右侧最终得到一个具有更大内在价值的新结构化数据集。

图1-2。使用经典批处理引擎进行有限的数据处理。左侧的有限数量的非结构化数据通过数据处理引擎运行，从而在右侧产生了相应的结构化数据。
尽管作为该方案的一部分，您实际可以计算的内容当然会有无限的变化，但总体模型非常简单。更有趣的是处理无边界数据集的任务。现在，让我们看一下通常会处理无边界数据的各种方式，首先是传统批处理引擎所使用的方法，最后是您可以为无边界数据设计的系统所采用的方法，例如大多数流或微批处理引擎。

### 无限数据：批处理
批处理引擎虽然没有明确考虑到无边界数据的设计，但自从最初想到批处理系统以来，就一直使用批处理引擎来处理无边界的数据集。如您所料，这种方法围绕将无边界数据切成适合批处理的有边界数据集组成。

#### 固定窗口
使用批处理引擎重复运行来处理无界数据集的最常见方法是，将输入数据窗口化为固定大小的窗口，然后将这些窗口中的每一个作为独立的有界数据源（有时也称为翻滚窗口）进行处理，如下所示：在图1-3中。特别是对于日志这样的输入源，事件可以写入其名称对应于其所对应的窗口的目录和文件层次结构中，这种事情一开始看起来就非常简单，因为您实际上已经执行了基于时间的随机操作来获取数据提前进入适当的事件时间窗口。

但是，实际上，大多数系统仍然要处理完整性问题（如果由于网络分区而导致某些事件在发送到日志时被延迟，该怎么办？如果您的事件是全局收集的并且必须转移到一个公共位置，该怎么办？处理之前？如果您的事件来自移动设备该怎么办？），这意味着有必要采取某种缓解措施（例如，延迟处理，直到您确定所有事件已被收集，或者在数据到达时重新处理给定窗口的整个批次）晚了）。

![image-20210330143052359](C:\Users\Rayan\Documents\笔记\streamingsystem\zh-cn\第一章 流式计算 101.assets\image-20210330143052359.png)

图1-3。通过具有经典批处理引擎的ad hoc固定窗口进行无界数据处理。将无界数据集预先收集到有限的固定大小的有界数据窗口中，然后通过连续运行经典批处理引擎对其进行处理。
#### 会话
当您尝试使用批处理引擎将无限制的数据处理为更复杂的窗口化策略（例如会话）时，这种方法会更加崩溃。会话通常被定义为由于不活动间隙而终止的事件时间段（例如，针对特定用户）。使用典型的批处理引擎计算会话时，通常会遇到将会话拆分为多个批次的情况，如图1-4中的红色标记所示。我们可以通过增加批量大小来减少拆分数量，但要以增加延迟为代价。另一个选择是添加其他逻辑以拼接来自先前运行的会话，但是以进一步的复杂性为代价。

![image-20210330143127328](C:\Users\Rayan\Documents\笔记\streamingsystem\zh-cn\第一章 流式计算 101.assets\image-20210330143127328.png)

图1-4。通过经典的批处理引擎通过专用的固定窗口将无限制的数据处理成会话。将无界数据集预先收集到有限的固定大小的有界数据窗口中，然后通过连续运行经典批处理引擎将其细分为动态会话窗口。
无论哪种方式，使用经典的批处理引擎来计算会话都不是理想的选择。更好的方法是以流方式建立会话，稍后我们将介绍。

### 无限数据：流式传输
与大多数基于批处理的无边界数据处理方法的即席性质相反，流系统是为无边界数据构建的。正如我们之前提到的，对于许多现实世界中的分布式输入源，您不仅发现自己正在处理无边界的数据，而且还处理以下数据：

- 事件时间高度无序，这意味着如果要在发生数据的上下文中分析数据，则需要在管道中进行某种基于时间的混洗。

- 事件时间偏斜的变化程度不同，这意味着您不能仅仅假设始终在时间Y的恒定ε内看到给定事件时间X的大部分数据。

处理具有这些特征的数据时，可以采用几种方法。我通常将这些方法分为四类：时间不可知，近似，按处理时间开窗和按事件时间开窗。

现在，让我们花一点时间来研究每种方法。

#### 时间不可知
与时间无关的处理用于时间基本上无关紧要的情况；也就是说，所有相关逻辑都是数据驱动的。由于有关这些用例的一切都是由更多数据的到来决定的，因此流数据引擎实际上并没有什么特别的除了基本数据传递外，还必须支持。结果，基本上所有现有的流系统都支持开箱即用的时间不可知的用例（一致性方面，模数间的模数差异当然可以保证，如果您关心正确性的话）。批处理系统还非常适合通过将无界源切成任意序列的有界数据集并独立处理这些数据集的方式，对无界数据源进行时间不可知的处理。我们在本节中看几个具体的例子，但是考虑到处理时间不可知的处理的直接性（至少从时间的角度来看），我们将不会在此上花费更多的时间。

#### 筛选
时间不可知处理的一个非常基本的形式是过滤，图1-5给出了一个示例。假设您正在处理网络流量日志，并且想要过滤掉并非来自特定域的所有流量。您将查看到达的每个记录，查看它是否属于感兴趣的域，如果不属于，则将其删除。因为这种事情在任何时候都仅取决于单个元素，所以数据源是无界的，无序的以及事件时间偏斜不同的事实是无关紧要的。

![image-20210330143220944](C:\Users\Rayan\Documents\笔记\streamingsystem\zh-cn\第一章 流式计算 101.assets\image-20210330143220944.png)

图1-5。过滤无限制的数据。各种类型的数据集合（从左到右流动）被过滤到包含单个类型的同类集合中。
#### 内部联接
另一个与时间无关的示例是内部联接，如图1-6所示。在联接两个无边界数据源时，如果您只关心两个源中的元素到达时的联接结果，则逻辑上没有时间性元素。在从一个来源看到一个值时，您可以简单地将其缓冲在持久状态下。仅在其他来源的第二个值到达后，才需要发出合并的记录。 （实际上，您可能需要某种针对未忽略的部分联接的垃圾回收策略，这可能是基于时间的。但是对于很少或没有未完成联接的用例来说，这样的事情可能不是问题。）

![image-20210330143237610](C:\Users\Rayan\Documents\笔记\streamingsystem\zh-cn\第一章 流式计算 101.assets\image-20210330143237610.png)


图1-6。对无边界数据执行内部联接。当观察到来自两个来源的匹配元素时，将生成联接。
将语义转换为某种外部联接会引入我们讨论过的数据完整性问题：看到联接的一侧后，如何知道另一侧是否会到达？实话实说，您没有，所以您需要引入一些超时概念，其中引入了时间元素。时间要素本质上是窗口化的一种形式，我们稍后将详细介绍。

#### 近似算法
方法的第二大类是近似算法，例如近似Top-N，流k均值等。它们采用无限的输入源并提供输出数据，如果您斜视它们，它们或多或少看起来就像您希望获得的那样，如图1-7所示。近似算法的优点是，根据设计，它们的开销很低，并且设计用于无限制的数据。缺点是它们存在的数量有限，算法本身通常很复杂（这使得很难构想出新算法），并且它们的近似性质限制了它们的实用性。

![image-20210330143302754](C:\Users\Rayan\Documents\笔记\streamingsystem\zh-cn\第一章 流式计算 101.assets\image-20210330143302754.png)

图1-7。计算无边界数据的近似值。数据通过复杂的算法运行，产生的输出数据或多或少看起来像另一边的期望结果。
值得注意的是，这些算法通常在设计中确实需要时间（例如，某种内置的衰减）。并且由于它们在到达元素时对其进行处理，因此该时间元素通常基于处理时间。这对于在近似值上提供某种可证明的误差范围的算法尤其重要。如果这些错误范围是根据有序到达的数据确定的，则当您以不同的事件时间偏斜向算法提供无序数据时，它们实际上就没有任何意义。要记住的事情。

逼近算法本身是一个引人入胜的主题，但是由于它们本质上是时间不可知处理的另一个示例（以算法本身的时间特征为模），因此使用起来非常简单，因此鉴于我们当前的关注重点，因此不值得进一步关注。

#### 开窗
其余两种用于无限制数据处理的方法都是窗口的变体。在深入探讨它们之间的差异之前，我应该先弄清楚窗口化的含义，因为在上一节中我们只是简要地谈到了这一点。窗口化只是简单的概念，即获取一个数据源（无界的或有界的），并沿时间边界将其切成有限的块以进行处理。图1-8显示了三种不同的窗口模式。

![image-20210330143320517](C:\Users\Rayan\Documents\笔记\streamingsystem\zh-cn\第一章 流式计算 101.assets\image-20210330143320517.png)

图1-8。窗口化策略。每个示例显示了三个不同的键，突出显示了对齐窗口（适用于所有数据）和未对齐窗口（适用于所有数据）之间的差异。跨数据子集）。
让我们仔细看看每种策略：

- 固定窗口（又名滚动窗口）
  我们之前讨论了固定窗口。固定的窗口将时间切成具有固定大小的时间长度的段。通常（如图1-9所示），将固定窗口的段均匀地应用于整个数据集，这是对齐窗口的一个示例。在某些情况下，最好对不同数据子集的窗口（例如每个键）进行相移，以使窗口完成负载随着时间的推移更均匀地分布，这是未对齐窗口的一个示例，因为它们在数据中会有所不同。[^6]

- 滑动窗口（又称跳窗）
  固定窗口，滑动窗口的一般化是由固定的长度和固定的周期定义的。如果周期小于长度，则窗口重叠。如果周期等于长度，则您有固定的窗口。而且，如果周期大于长度，那么您将拥有一种奇怪的采样窗口，该采样窗口只能查看一段时间内数据的子集。与固定窗口一样，滑动窗口通常是对齐的，尽管在某些用例中它们可以作为性能优化而未对齐。请注意，图1-8中的滑动窗口是按原样绘制的，以提供滑动运动的感觉;实际上，所有五个窗口将应用于整个数据集。

- 会话
  动态窗口的一个示例是，会话由事件序列组成，这些事件序列以不活动的间隔大于某个超时终止。会话通常用于通过将一系列与时间相关的事件（例如，一个坐着观看的视频序列）组合在一起来分析一段时间内的用户行为。会话很有趣，因为它们的长度不能事先定义。它们取决于所涉及的实际数据。它们也是未对齐窗口的典型示例，因为会话实际上在不同的数据子集（例如，不同的用户）之间永远不会完全相同。

我们前面讨论的两个时间语义（处理时间和事件时间）本质上是我们关心的两个领域。[^7]在这两个域中，窗口化都是有意义的，因此让我们详细研究每个域并了解它们之间的不同。由于处理时间窗口化在过去一直很普遍，因此我们将从这里开始。

#### 按处理时间开窗
当按处理时间进行窗口化时，系统实际上会将传入的数据缓冲到窗口中，直到经过了一定数量的处理时间为止。例如，对于五分钟的固定窗口，系统将缓冲数据五分钟的处理时间，然后将其在那五分钟内观察到的所有数据视为一个窗口，并将其发送到下游进行处理。

![image-20210330143430939](C:\Users\Rayan\Documents\笔记\streamingsystem\zh-cn\第一章 流式计算 101.assets\image-20210330143430939.png)


图1-9。通过处理时间开窗进入固定窗口。数据根据它们到达管道的顺序收集到窗口中。
处理时间开窗有一些不错的属性：

- 这很简单。该实现非常简单，因为您不必担心会在一定时间内对数据进行混洗。您只需在事物到达时对其进行缓冲，并在窗口关闭时将其发送到下游。

- 判断窗口的完整性很简单。因为系统具有关于是否已经看到窗口的所有输入的完美知识，所以它可以对给定窗口是否完整做出完美的决策。这意味着在按处理时间进行窗口化处理时，无需以任何方式处理“后期”数据。

- 如果您想推断有关来源的信息，那么处理时间窗口就是您想要的。许多监视方案都属于此类。想象一下，跟踪每秒发送到全局Web服务的请求数。为检测中断而计算这些请求的比率是对处理时间窗口的完美利用。

抛开优点，处理时间窗口化有一个很大的缺点：*如果所讨论的数据具有与事件时间相关联的事件时间，则如果处理时间窗口要反映何时发生的现实，则这些数据必须按事件时间顺序到达。这些事件实际上发生了。*不幸的是，事件时间排序的数据在许多实际的分布式输入源中并不常见。

举一个简单的例子，想象一下任何收集使用情况统计信息以供以后处理的移动应用程序。对于给定移动设备离线任何时间的情况（短暂的连接中断，在全国范围内飞行时的飞行模式等），在此期间记录的数据只有在设备再次联机后才会上传。这意味着数据可能以几分钟，几小时，几天，几周或更长时间的事件时间偏差到达。在按处理时间窗口化时，从这样的数据集中得出任何有用的推断基本上是不可能的。

作为另一个示例，当整个系统运行状况良好时，许多分布式输入源似乎可以提供事件时间排序（或几乎如此）的数据。不幸的是，当我健康时，输入源的事件时间偏斜很低的事实并不能解决。它会一直保持这种状态。考虑一个全球服务，该服务处理在多个大洲收集的数据。如果跨带宽受限的跨大陆线路（不幸的是，这很常见）的网络问题进一步降低了带宽和/或增加了延迟，则突然部分输入数据可能比以前更大地开始到达。如果按处理时间对这些数据进行窗口化处理，则窗口将不再代表其中实际发生的数据。相反，它们表示事件到达处理管道时的时间窗口，这是旧数据和当前数据的任意混合。

在这两种情况下，我们真正想要的是按照事件的时间对数据进行窗口化，从而对事件的到达顺序具有鲁棒性。我们真正想要的是事件时间窗口。

#### 按事件时间开窗
当需要以有限的块观察数据源时，可以使用事件时间窗口来反映那些事件实际发生的时间。这是开窗的黄金标准。在2016年之前，大多数使用的数据处理系统都缺乏对它的本机支持（尽管任何具有像样的一致性模型的系统，例如Hadoop或Spark Streaming 1.x，都可以充当构建此类窗口系统的合理基础）。我很高兴地说，当今的世界看起来非常不同，从Flink到Spark到Storm到Apex都有多个系统，它们本来就支持某种事件时间窗口。

图1-10显示了一个示例，该示例将无限制的源窗口化为一小时的固定窗口。

![image-20210330143600031](C:\Users\Rayan\Documents\笔记\streamingsystem\zh-cn\第一章 流式计算 101.assets\image-20210330143600031.png)

图1-10。通过事件时间进入固定窗口。数据根据其发生的时间收集到窗口中。黑色箭头标出到达处理时间窗口的示例数据，这些数据不同于它们所属的事件时间窗口。
图1-10中的黑色箭头标出了两个特别有趣的数据。每个事件到达的处理时间窗口与每个数据位所属的事件时间窗口不匹配。这样，如果针对关注事件时间的用例将这些数据放入处理时间窗口中，则计算结果将是不正确的。如您所料，事件时间正确性是使用事件时间窗口的一件好事。

关于在无边界数据源上进行事件时间窗口化的另一件好事是，您可以创建动态大小的窗口（例如会话），而在固定窗口上生成会话时不会观察到任何分裂（正如我们先前在会话示例中从“无边界数据”中看到的那样） ：Streaming”），如图1-11所示。

![image-20210330143618186](C:\Users\Rayan\Documents\笔记\streamingsystem\zh-cn\第一章 流式计算 101.assets\image-20210330143618186.png)

图1-11。通过事件时间进入会话窗口。数据被收集到会话窗口中，这些窗口基于相应事件发生的时间来捕获活动突发。黑色箭头再次指出将数据放入其正确的事件时间位置所必需的时间上的随机播放。
当然，强大的语义很少免费提供，事件时间窗口也不例外。事件时间窗口有两个显着的缺点，这是由于以下事实：窗口的生存时间（在处理时间上）通常必须长于窗口本身的实际长度：

- 正在缓冲
  由于延长了窗口寿命，因此需要更多的数据缓冲。幸运的是，持久存储通常是大多数数据处理系统所依赖的资源类型中最便宜的（其他主要是CPU，网络带宽和RAM）。因此，与使用任何设计良好，具有高度一致的持久状态和良好的内存缓存层的数据处理系统相比，此问题通常比您可能想到的要少得多。同样，许多有用的聚合不需要缓冲整个输入集（例如，求和或平均），而是可以增量地执行，而持久化状态下存储的中间聚合则小得多。

- 完整性
  鉴于我们通常不知道何时看到给定窗口的所有数据，因此如何知道何时可以实现窗口的结果呢？实际上，我们根本不这样做。对于许多类型的输入，系统可以通过诸如MillWheel，Cloud Dataflow和Flink（我们将在第3章和第4章中详细介绍）中的水印之类的东西，对窗口完成进行合理准确的启发式估计。但是，对于绝对正确性至高无上的情况（再次考虑帐单），唯一的真实选择是为管道构建器提供一种方法，使他们能够表达何时希望实现窗口的结果以及如何随着时间的推移细化这些结果。处理窗口完整性（或缺乏窗口完整性）是一个引人入胜的话题，但是在具体示例的背景下，也许是最好的探索方法，接下来我们将对其进行探讨。

## 概括
ew！那是很多信息。如果您已经做到了这一点，那就值得赞扬！但是我们才刚刚开始。在继续深入研究Beam Model appr之前算了，让我们简单地退一步，回顾一下到目前为止所学到的知识。在本章中，我们完成了以下操作：

- 澄清术语，将“流”的定义集中于指的是考虑到无限制数据构建的系统，同时对通常归类于“流”的伞下的不同概念使用更具描述性的术语，例如近似/推测性结果。此外，我们重点介绍了大型数据集的两个重要方面：基数（即有界与无界）和编码（即表与流），后者将占用本书后半部分的大部分时间。

- 评估设计良好的批处理和流系统的相对功能后，假定流实际上是批的严格超集，并且像Lambda体系结构这样的概念基于流不如批处理而注定要随着流系统的成熟而淘汰。 。

- 提出了两个高级概念，它们是流系统赶上并最终超过批处理所必需的，分别是正确性和时间推理工具。

- 建立了事件时间与处理时间之间的重要差异，描述了差异在发生数据的上下文中分析时所带来的困难，并提出了从完整性的概念转向简单地适应随时间变化的数据的方法。

- 通过批处理和流引擎研究了当今常用的有界和无界数据的主要数据处理方法，将无界方法粗略地分类为：时间不可知，近似，按处理时间进行开窗和按事件时间进行开窗。

接下来，我们将深入研究Beam模型的细节，从概念上看我们如何在四个相关的轴上分解数据处理的概念：什么，在哪里，何时以及如何。我们还将详细研究如何处理多个场景下的简单，具体的示例数据集，重点介绍Beam模型支持的多个用例，并结合一些具体的API来使我们现实起来。这些示例将有助于带动本章介绍的事件时间和处理时间的概念，同时还探索诸如水印之类的新概念。

[^1]: 为了完整起见，可能值得一提的是，这个定义既包括真正的流式传输，也包括微批量实现。对于不熟悉微批处理系统的人来说，它们是流式处理系统，它们使用批处理引擎的重复执行来处理无限制的数据。 Spark Streaming是行业中的典型示例。
[^2]:熟悉我最初的“ Streaming 101”文章的读者可能会记得，我相当强调鼓励在引用数据集时放弃“ stream”一词。从来没有流行，我最初认为是由于它的易用性和普遍使用的现有用法。回想起来，我认为我是完全错误的。实际上，区分两种不同类型的数据集结构（表和流）具有很大的价值。确实，本书后半部分大部分致力于理解这两者之间的关系。
[^3]:如果您不熟悉我所说的“一次”的意思，则是指某些数据处理框架提供的特定类型的一致性保证。一致性保证通常分为三大类：最多一次处理，至少一次处理和完全一次处理。请注意，此处使用的名称是指在管道生成的输出中观察到的有效语义，而不是管道可能处理（或尝试处理）任何给定记录的实际次数。因此，有时使用有效一次一词代替完全一次一词，因为它更能代表事物的内在本质。鲁汶将在第5章中更详细地介绍这些概念。
[^4]: 自从最初发布“ Streaming 101”以来，许多人向我指出，将处理时间放在x轴上并将事件时间放在y轴上会更加直观。我确实同意，交换两个轴最初会感觉更自然，因为事件时间似乎是处理时间的自变量的因变量。但是，由于两个变量都是单调的并且密切相关，因此它们实际上是相互依存的变量。因此，我认为从技术角度来看，您只需要选择一个轴并坚持下去即可。数学是令人困惑的（尤其是在北美以外的地方，它突然变得复数并与您结盟）。
[^5]: 这个结果确实并不令人惊讶（但是对我来说，因此我要指出这一点），因为在测量两种类型的偏斜/滞后时，我们有效地创建了一条具有理想线的直角三角形。数学很酷。
[^6]: 我们将在第2章中详细介绍对齐的固定窗口，并在第4章中详细介绍未对齐的固定窗口。
[^7]: 如果是在学术文献或基于SQL的流系统中进行足够的讨论时，您还会遇到第三个窗口时间语义：基于元组的窗口（即，其大小以元素数量计算的窗口）。 但是，基于元组的窗口化实质上是处理时间窗口化的一种形式，其中元素在到达系统时被分配为单调递增的时间戳。 因此，我们将不再详细讨论基于元组的窗口。